---
date: 2022-10-07
pinned: false
title: Building a basic Markdown parser
---

> This is in the process of being written, so check back on it often for updates!

As part of a [ten-day challenge](https://events.hackclub.com/10-days-in-public/) to work on building something cool, I'm writing a Markdown parser in JavaScript. I'm actually writing this on day three of the challenge, so I'll just skim over the last two days and start documenting the process together.

I'm currently relying on two resources to write the parser:

* [Notes on making a Markdown parser from scratch in JS](https://sarvasvkulpati.com/blog/markdown-parser): No code (I took a look at the demo but not the source code itself), but it does a really good job of explaining concepts like tokenizer &rarr; parser &rarr; the actual HTML generation really well from a theoretical standpoint.
* [Chapter 6 of *Eloquent JavaScript*, first editon](https://eloquentjavascript.net/1st_edition/chapter6.html): Yes, I know that the current edition is the third one. Yes, I have read half of that and still have yet to finish the other half. Actually, despite being a chapter on functional programming with JavaScript, this provides a lot of insight into writing a Markdown parser, since it explains how to write a basic parser that can parse headings, italics, and footnotes.

For this challenge, I want to write my own Markdown parser, which essentially means I want to be reliant on tutorials and Stack Overflow as little as possible. This means potentially *convoluted* and idiotic code, which I completely acknowledge. However, it also means that whatever code I'm writing is code that I can learn from. At the same time, I also want to be able to gain a deeper understanding of the terminology behind writing a parser, even if it's particularly basic. Hence, the two articles above.

## The concept

Currently, all of the code behind the Markdown parser is in one file; the only dependency is `highlight.js`, for highlighting the code. This is what happens when the user types in input:

1. The input gets passed to a function, `parseMarkdown`. This function tries to split up the input into chunks, such as a code block.
2. These chunks are passed one by one into a function called `processBlock`, which is part of the tokenizer. (More info to be included later.) This tokenizer is responsible for converting, say, using the example before, a code block into an object, or a token, like `{ type: "codeBlock", content: ..., attributes: { lang } }`. This tokenizer is recursive for certain types of content, such as italics.
3. Once the tokens have been generated, they're parsed, which just means they're transformed into a form closer to HTML. In the case of the parser I've written, it just takes the tokens and creates a tree-like data structure using a object representation for HTML, where each tag is described as `{ name, content, attributes }`.
4. Finally, the tree that the parser generates is converted into HTML, once again using recursion. One issue here is that of escaping HTML, which `highlight.js` has warned me of already. I might take a closer look into it later.

## Day 3 & 4

(Like I mentioned before, I'm jumping ahead since I started writing this on day 3.) Today, I figured out how to parse code blocks. After struggling with it for two hours, I finally deleted what I had been writing and rewrote it in a smarter way in ten minutes. Bugs, as they say, take up more time than programming. So does thinking through things.

> I'll include some shots once I'm done! For now, this is a quick writeup.